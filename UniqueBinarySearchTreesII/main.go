package main

type TreeNode struct {
	Val   int
	Left  *TreeNode
	Right *TreeNode
}

func main() {

}

func generateTrees(n int) []*TreeNode {
	if n == 0 {
		return []*TreeNode{}
	}

	return generate(1, n)
}


// this is generated by recognizing the fact that the total number of possible
// subtrees is a Catalan number. Catalan numbers are represented by the
// following equation: C(N+1) = ((2(2N + 1))/(N+2))C(N)
func generate(start, end int) []*TreeNode {
	allTrees := []*TreeNode{}
	if start > end {
		return append(allTrees, nil)
	}

	if start == end {
		return append(allTrees, &TreeNode{Val: start})
	}

	for i := start; i < end+1; i++ { // pick up a root
		// all possible left subtrees if i is chosen to be a root
		leftSubtrees := generate(start, i-1)

		// all possible right subtrees if i is chosen to be a root
		rightSubtrees := generate(i+1, end)

		// connect left and right subtrees to the root i
		for _, l := range leftSubtrees {
			for _, r := range rightSubtrees {
				currentTree := &TreeNode{Val: i}
				currentTree.Left = l
				currentTree.Right = r
				allTrees = append(allTrees, currentTree)
			}
		}
	}

	return allTrees
}
